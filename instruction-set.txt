Idx | Reg | Bits | Function
0   | A   | 8    | General purpose/accumulator
1   | B   | 8    | General purpose
2   | C   | 8    | General purpose
3   | H   | 8    | High bits of 16 bit general purpose reg HL
4   | L   | 8    | Low bits of HL
5   | PC  | 16   | Program counter
6   | SP  | 8    | Stack pointer
7   | BP  | 8    | Base pointer

([<REG>] means "value at memory address <REG>")

16 bits per instruction
Op    | Name   | Usage                               | Description
00000 | ADD    | ADD  <REG 1>, <REG 2>               | Adds value of <REG 2> to <REG 1>
00001 | SUB    | SUB  <REG 1>, <REG 2>               | Subtracts value of <REG 2> from <REG 1>
00010 | unused
00011 | CMP    | CMP  <REG 1>, <REG 2>               | compares <REG 1> with <REG 2>
00100 | ADC    | ADC  <REG 1>, <REG 2>               | Adds <REG 2> and carry flag to <REG 1>
00101 | SBC    | SBC  <REG 1>, <REG 2>               | Subtracts <REG 2> and the carry flag from <REG 1>
00110 | NAND   | NAND <REG 1>, <REG 2>               | NANDs <REG 1> with <REG 2> 
00111 | XOR    | XOR  <REG 1>, <REG 2>               | XORs <REG 1> with <REG 2>
01000 | unused
01001 | SHR    | SHR  <REG>                          | Right-Shifts <REG>
01010 | unused
01011 | unused
01100 | ADDI   | ADD  <REG>, <Immediate>             | adds the immediate value to <REG>
01101 | SUBI   | SUB  <REG>, <Immediate>             | subtracts the immediate value from <REG>
01110 | CMPI   | CMP  <REG>, <Immediate>             | compares <REG> with the immediate value
01111 | JMP    | JMP  <Address>                       | jumps to relative adress <Address>
10000 | JZ     | JZ   <Address>                       | jumps to relative adress <Address> if zero flag is set
10001 | JN     | JN   <Address>                       | jumps to relative adress <Address> if negative flag is set
10010 | JP     | JP   <Address>                       | jump if positive flag is set
10011 | LDIR   | LD   <REG>, <Immediate>             | loads value <Immediate> into <REG>
10100 | LDRR   | LD   <REG 1>, <REG 2>               | loads value from <REG 2> in to <REG 1>
10101 | LDRMR  | LD   <REG 1>, [<REG 2>]             | loads the value of the dereferenced bytepointer <REG 2> in to <REG 1>
10110 | LDMRR  | LD   [<REG 1>], <REG 2>             | loads the value of <REG 2> into the bytepointer <REG 1>
10111 | LDRMRR*| LD   <REG 1>, [<REG 2> + <REG 3>]   | loads the value of the dereferenced bytepointer wich is the xreult of the addition of <REG 2> and <REG 3> in to <REG 1>
11000 | LDMRRR*| LD   [<REG 1> + <REG 2>], <REG 3>   | loads the value of <REG 1> in to the bytepointer wich is the reult of the addition of <REG 2> and <REG 3> 
11001 | PUSH   | PUSH <REG>                          | Pushes value of <REG> on to the stack
11010 | POP    | POP  <REG>                          | Pulls value of <REG> off the stack
11011 | SCF    | SCF                                 | Sets the carry flag
11100 | RCF    | RCF                                 | Resets the carry flag
11101 | CALL   | CALL <Address>                      | Push PC, jump to <Address>
11110 | RET    | RET                                 | Alias for pop PC (May not implement in hardware)
11111 | NOP    | NOP                                 | does literally nothing

*don't actually build these but they're here in case
Possible ways to reduce complexity:
- hard wire register A to some functions, e.g. first or second operand of ALU instructions, or destination of ALU instructions
- get rid of the more complex addressing modes (LDRMRR, LDMRRR)

instruction format
==================

5 bits for opcode
then either:
    3 bits for source register and 3 bits for destination
or
    11 bits for relative jump address
or
    3 bits for register, 3 bits unused and 8 bits for immediate value

00000 xxx xxx xxxxx -> NOP
00001 001 010 xxxxx -> ADD A, B
  |    |   |  
  |    |   \-- Reg B
  |    \------ Reg A
  \----------- ADD opcode


01001 111 11111001
  |    |   |
  |    \---\-- -7 words, two's compliment
  \----------- JZ opcode

01010 001 xxx 01010101 -> LD b, 85
  |    |       |      
  |    |       |
  |    |       \------- numeber 85
  |    \--------------- Register B
  \-------------------- LDIR opcode


TODO:
- Figure out how HL as a pair could be used